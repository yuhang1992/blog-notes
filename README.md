## SCSS

学习SCSS,先要明白SCSS与Sass的区别:
- SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能.

- SCSS 还能识别大部分 CSS hacks（一些 CSS 小技巧）和特定于浏览器的语法，例如：古老的 IE filter 语法。
- SCSS 需要使用分号和花括号而不是换行和缩进.

## Sass

又叫Syntactically Awesome StyleSheets.

优势/特色:

- 完全兼容 CSS3
- 在 CSS 语言基础上添加了扩展功能，比如变量、嵌套 (nesting)、混合 (mixin)
- 对颜色和其它值进行操作的{Sass::Script::Functions 函数}
- 函数库控制指令之类的高级功能
- 良好的格式，可对输出格式进行定制
- 支持 Firebug

### 缓存

  默认情况下，Sass 会对编译过的模板（template）和partials 进行缓存。 这将明显加快大量 Sass 文件的重新编译速度， 并且在 Sass 模板被切割为多个文件并通过 @import 引入形成一个大文件时效果最好。

  如果不使用框架，Sass 将会把缓存的模板放入 .sass-cache 目录。 在 Rails 和 Merb 中，将被放到 tmp/sass-cache 目录。 此目录可以通过 :cache_location 选项进行配置。 如果你不希望 Sass 启用缓存功能， 可以将 :cache 选项设置为 false。

###　选项

可以通过在Rails或Rack 中设置Sass :: Plugin＃options hash 来设置选项environment.rbconfig.ru

```
  Sass::Plugin.options[:style] = :compact
```

或通过在Merb 中设置Merb::Plugin.config[:sass]哈希init.rb...

```
  Merb::Plugin.config[:sass][:style] = :compact
```

或通过将选项哈希传递给Sass :: Engine＃initialize。所有相关选项也可以通过标志sass和scss命令行可执行文件来获得。可用选项有：只列举常见的

- :style  设置CSS输出的样式.

  ```

    1. :nested:  嵌套样式是默认的Sass样式，因为它反映了CSS样式的结构和他们所设计的HTML文档。每个属性都有自己的行，但缩进不是固定不变。根据嵌套的深度，每个规则都是缩进的
    2. :expanded: 扩展是一个更加典型的自定义的CSS风格，每个属性和规则占一线。属性在规则中缩进，但是规则不以任何特殊方式缩进
    3. :compressed: 压缩样式占用尽可能少的空间，除了分隔选择器和文件末尾的换行符之外，没有空格。它还包括一些其他轻微的按压，例如选择最小的颜色表示。可读性不是很好。
    4. :compact 紧凑型采用比嵌套或扩展更少的空间。它还将重点放在选择器上而不是他们的属性。每个CSS规则仅占用一行，每行都在该行上定义。嵌套规则彼此相邻，没有换行符，而单独的规则组在它们之间具有换行符

  ```
- :syntax 输入文件的语法，:sass缩进语法和:scss的CSS扩展语法。这仅在您自己构建Sass :: Engine实例时有用; 当使用Sass :: Plugin时，它会自动设置。默认为:sass。
- :cache 解析Sass文件是否应该被缓存，从而允许更快的速度。默认为true。

### 编码

Sass默认输出编码为UTF-8.你也可以通过使用@charset像CSS一样的声明.

### 扩展功能

- 嵌套规则

  Sass允许CSS规则彼此嵌套。内部规则只适用于外部规则的选择器。例如：

  ```

  #main p {
    color: #00ff00;

    .redbox {
      background-color: #ff0000;
    }
  }

  ```
  优点:  这有助于避免重复父选择器，并使复杂的CSS布局通过大量的使用嵌套选择器变得更简单.

- 引用父选择符： &

  有时候，我们需要在嵌套规则里面使用嵌套规则的父选择器。例如，给链接标签增加悬停的效果,在这些情况下，您可以使用字符&来显式指定父选择器的插入位置。例如：

  ```
  a {
    font-weight: bold;
    text-decoration: none;
    &:hover { text-decoration: underline; }
    body.firefox & { font-weight: normal; }
  }
  ```
  & 在编译时将被替换为父选择符，输出到 CSS 中.

  &必须出现在复合选择器的开头，但可以后面跟一个将被添加到父选择器的后缀.例如：

  ```
  #main {
    color: black;
    &-sidebar { border: 1px solid; }
  }

  ```
  如果父选择器不能应用后缀，则Sass将抛出一个错误。

- 嵌套属性

  CSS有很多复合属性在“命名空间”中,例如font-family，font-size和font-weight都在font命名空间.

  在CSS中，如果要在同一个命名空间中设置一堆属性，则必须每次都键入它。Sass为此提供了一个快捷方式：只需写入一次名称空间，然后嵌套其中的每个子属性.例如：

  ```

  .funky {
    font: {
      family: fantasy;
      size: 30em;
      weight: bold;
    }
  }

  ```

  属性命名空间本身也可以有一个值。例如：

  ```
  .funky {
    font: 2px/3px {
      family: fantasy;
      size: 30em;
      weight: bold;
    }
  }

  ```

- 占位符选择器： %foo

  Sass支持一种特殊类型的选择器，称为“占位符选择器”。它们是用来与@extend指令一起使用的;

- 注释 /* */ and //

  Sass支持标准的多行CSS注释/* */以及单行注释//。多行注释在一些情况下保留在CSS输出中，而单行注释被删除.

  ```
  /* This comment is
   * several lines long.
   * since it uses the CSS comment syntax,
   * it will appear in the CSS output. */
  body { color: black; }

  // These comments are only one line long each.

  ```
  当多行注释的第一个字母时为!，即使在压缩输出模式下，注释也将始终呈现在css输出里面。这对把版权声明添加到生成的CSS中很有用.

  由于多行注释成为输出CSS的一部分，因此可以解析其中的变量。例如：

  ```
  $version: "1.2.3"; // 下列中可以使用这变量
  /* This CSS is generated by My Snazzy Framework version #{$version}. */

  ```

- SassScript

  除了纯CSS属性语法，Sass还支持一小部分称为SassScript的扩展。SassScript允许属性使用变量，算术和额外的函数。SassScript可用于任何属性值。

  SassScript也可用于生成选择器和属性名称，这在编写mixins时非常有用。这是通过插值完成的。


  1. 变量： $

  使用SassScript最简单的方法是使用变量。变量以美元符号开始，并设置为CSS属性,然后，您可以在属性中引用它们.

  变量只能在定义它们的嵌套选择器的级别中使用。它们也可以用!global来定义，在这种情况下，它们是全局的。例如：

  ```
  #main {
    $width: 5em !global;
    width: $width;
  }

  #sidebar {
    width: $width;
  }
  ```
  由于历史原因，变量名称（和所有其他Sass标识符）可以互换使用连字符和下划线。例如，如果您定义了一个调用的变量$main-width，那么可以将其访问$main_width，反之亦然。


2. 数据类型

SassScript支持七种主要数据类型：

- 数字（例如1.2，13，10px）
- 文本字符串，使用和不使用引号（例如"foo"，'bar'，baz）

  ```
    CSS指定两种字符串：带引号的字符串，例如"Lucida Grande"或'http://sass-lang.com'，
    以及没有引号的字符串，例如sans-serif或bold。SassScript识别这两种类型，
    一般来说，如果在Sass文档中使用了一种字符串，那么在生成的CSS中将使用该类型的字符串。
    但是有一个例外,当使用#{}插值时，引用的字符串是不引用的。这使得在mixins中更容易使用eg选择器名称。例如:

  ```
  ```
  @mixin firefox-message($selector) {
    body.firefox #{$selector}:before {
      content: "Hi, Firefox users!";
    }
  }

  @include firefox-message(".header");

  ```



- 颜色（例如blue，#04a3f9，rgba(255, 0, 0, 0.5)）
- 布尔值（例如true，false）
- 空（例如null）
- 以空格或逗号分隔的值列表（例如1.5em 1em 0 2em，Helvetica, Arial, sans-serif）

  主要涉及一些列表函数:
  ```

  1. nth function 可以访问列表中的项目
  2. join function 可以一起加入多个列表
  3. append function 可以将项目添加到列表中
  4. @each指令还可以添加列表中每个项目的样式

  ```
  列表除了包含简单的值之外，列表还可以包含其他列表.

  如果内部列表与外部列表具有相同的分隔符，则需要使用括号()来区分内部列表.

- 从一个值映射到另一个值（例如(key1: value1, key2: value2)）

  Maps表示键和值之间的关联，其中键用于查找值。它们可以轻松地将值收集到命名组中，并动态访问这些组。它们在CSS中没有直接的并行性，尽管它们在语法上类似于媒体查询表达式：

  ```
  $map: (key1: value1, key2: value2, key3: value3);
  ```

  与Lists不同，Maps必须始终用括号括起来，并且必须始终以逗号分隔。Maps中的键和值都可以是任何SassScript对象。Maps可能只有一个与给定键相关联的值（尽管该值可能是一个列表）。但是，给定的值可能与许多键相关联。

  像Lists一样，Maps大多使用SassScript函数进行操作。如@each指令可用于为Maps中的每个键/值对添加样式。Maps中的对顺序始终与创建Maps时的顺序相同。

  Maps键可以是任何Sass数据类型（甚至另一个Maps）.

  Maps无法转换为纯CSS。使用一个作为CSS函数的变量或参数的值将导致错误。使用该inspect($value)函数产生一个有用的调试地图的输出字符串。

3. 数字操作

    SassScript支持对数字（加法+，减法-，乘法*，除法/和模数%）的标准算术运算。算术运算时，Sass数学函数保留单位。这意味着，就像在现实生活中一样，你不能使用不兼容单位的数字进行运算，两个数字与相乘的单位相乘将产生平方单位（10px * 10px == 100px * px）。请注意，这px * px是一个无效的CSS单元，您将收到Sass的错误，试图在CSS中使用无效单元。

    关系运算符（<，>，<=，>=）也支持数字和相等运算符（==，!=），支持所有类型。

    - 除法运算和 /

      CSS 允许 / 出现在属性值里，作为分隔数字的一种方法。 既然 SassScript 是 CSS 属性语法的扩展， 他就必须支持这种语法，同时也允许 / 用在除法运算上。 也就是说，默认情况下，在 SassScript 里用 / 分隔的两个数字， 都会在 CSS 中原封不动的输出。

      然而，在以下三种情况中，/ 会被解释为除法运算。 这就覆盖了绝大多数真正使用除法运算的情况。 这些情况是：

      如果数值或它的任意部分是存储在一个变量中或是函数的返回值。
      如果数值被圆括号包围。
      如果数值是另一个数学表达式的一部分。

      如果你希望在纯 CSS 中使用变量和 /， 你可以用 #{} 包住变量.

      ```
      p {
        $font-size: 12px;
        $line-height: 30px;
        font: #{$font-size}/#{$line-height};
      }

      ```

    - 颜色运算

      所有算数运算都支持颜色值， 并且是分段运算的。 也就是说，红、绿、蓝各颜色分量会单独进行运算。 例如：

      ```
      p {
        color: #010203 + #040506;
      }

      ```

      请注意，使用Alpha通道的颜色（使用rgba或hsla函数创建的颜色）必须具有相同的Alpha值，以便与其一起完成颜色算术。算术不影响alpha值.
      可以使用不透明和透明功能调整颜色的Alpha通道.

    - 字符串操作

      +操作可用于连接字符串：
      注意，如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 例如：
      ```
      p:before {
        content: "Foo " + Bar;
        font-family: sans- + "serif";
      }

      ```
      编译为:

      ```
      p:before {
      content: "Foo Bar";
      font-family: sans-serif; }

      ```
      在文本字符串中，#{} 形式的表达式可以被用来在字符串中添加动态值：
      ```
      p:before {
        content: "I ate #{5 + 10} pies!";
      }

      ```

    - 布尔运算

      SassScript 支持布尔值做 and、or 和 not 运算。

    - 列表操作

      列表不支持任何特殊操作。而是使用列表功能进行操作。

    - 括号

      括号可用于影响操作顺序：

  4. 插值： #{}

      您还可以使用插值语法在选择器和属性名称中使用#{}SassScript变量：

      ```
      $name: foo;
        $attr: border;
        p.#{$name} {
        #{$attr}-color: blue;
      }
      ```

  5. 变量默认值： !default

      你可以在变量尚未赋值前，通过在值的末尾处添加 !default 标记来为其指定。 也就是说，如果该变量已经被赋值， 就不会再次赋值， 但是，如果还没有被赋值，就会被指定一个值。
      例如：

      ```
      $content: "First content";
      $content: "Second content?" !default;
      $new_content: "First time reference" !default;

      #main {
      content: $content;
      new-content: $new_content;
      }

      ```
      变量的值如果是 null 的话，会被 !default 当做没有值：

  6. @ 规则和指令

      - @import

        Sass 扩展了 CSS 的 @import 规则，让它能够引入 SCSS 和 Sass 文件。 所有引入的 SCSS 和 Sass 文件都会被合并并输出一个单一的 CSS 文件。 另外，被导入的文件中所定义的变量或 mixins 都可以在主文件中使用。

        Sass 会在当前目录下寻找其他 Sass 文件， 如果是 Rack、Rails 或 Merb 环境中则是 Sass 文件目录。 也可以通过 :load_paths 选项 或者在命令行中使用 --load-path 选项来指定额外的搜索目录。

        @import 根据文件名引入。 默认情况下，它会寻找 Sass 文件并直接引入， 但是，在少数几种情况下，它会被编译成 CSS 的 @import 规则：

        - 如果文件的扩展名是.css。
         - 如果文件名以 http:// 开头。
         - 如果文件名是 url()
         - 如果 @import 包含了任何媒体查询（media queries）

        如果没有满足上述条件，并且扩展名为.scss或.sass，则将导入命名的Sass或SCSS文件。如果没有扩展名，萨斯将尝试找到具有该名称的文件和.scss或.sass延伸和导入。

      - 片段

        如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。

        例如，你有一个文件叫做 _colors.scss。 这样就不会生成 _colors.css 文件了， 而且你还可以这样做 .
        ```
          @import "colors";

        ```
        来引入 _colors.scss 文件。
        注意，在同一个目录不能同时存在带下划线和不带下划线的同名文件.

      - 嵌套 @import

        虽然大多数时候只需要在文档的顶部使用@import，但是，你还可以把他们包含在 CSS 规则 和 @media 规则中。通过@import导入的规则将嵌套在与原始文件相同的位置。

        例如，如果example.scss包含:
        ```
        .example {
          color: red;
        }
        ```
        然后
        ```
        #main {
          @import "example";
        }
        ```

        编译后
        ```
        #main .example {
          color: red;
        }
        ```
      - @media

          Sass中的@media指令的行为就像在单纯CSS中一样，但具有一个额外的功能：它们可以嵌套在CSS规则中。如果@media指令出现在CSS规则中，它将被冒泡到样式表的顶层，将所有选择器放在规则中。这样可以轻松添加媒体特定的样式，而无需重复选择器或打破样式表的流程。例如：

          ```
          .sidebar {
            width: 300px;
            @media screen and (orientation: landscape) {
              width: 500px;
            }
            }
          ```
          编译后
          ```
          .sidebar {
            width: 300px; }
            @media screen and (orientation: landscape) {
              .sidebar {
                width: 500px; } }
          ```

          @media查询也可以嵌套在一起。然后使用and运算符组合查询。例如：

          ```
          @media screen {
            .sidebar {
              @media (orientation: landscape) {
                width: 500px;
              }
            }
            }

          ```

          编译后
          ```
            @media screen and (orientation: landscape) {
              .sidebar {
                width: 500px; } }
          ```

          最后，@media查询可以包含SassScript表达式（包括变量，函数和运算符）来代替特征名称和特征值。例如：

          ```
          $media: screen;
          $feature: -webkit-min-device-pixel-ratio;
          $value: 1.5;

          @media #{$media} and ($feature: $value) {
          .sidebar {
            width: 500px;
          }
          }
          ```

      - @extend

          当一个类应该具有另一个类的所有样式以及其自己的特定样式时，最常见的处理方式是在HTML中使用更一般的类和更特定的类。例如，假设我们有一个正常错误的类，以及一个严重的错误的类。我们可能会这样写我们的标记：

          ```
          .error {
            border: 1px #f00;
            background-color: #fdd;
          }
          .seriousError {
            border-width: 3px;
          }
          ```
          不幸的是，这意味着我们必须永远记住使用.error与.seriousError的不同。这是一个维护负担，导致棘手的错误，并且可以将非语义风格的问题带入标记。

          该@extend指令通过告诉Sass一个选择器应该继承另一个选择器的样式来避免这些问题。例如：

          ```
          .error {
            border: 1px #f00;
            background-color: #fdd;
          }
          .seriousError {
            @extend .error;
            border-width: 3px;
          }

          ```
      - 扩展复杂选择器

          类选择器不是唯一可以被扩展的选项。可以扩展任何只涉及单个元素的选择器，例如.special.cool，a：hover或a.user [href ^ =“http：//”]。例如：

          ```
          .hoverlink {
            @extend a:hover;
          }
          a:hover {
            text-decoration: underline;
          }
          ```

      - 多个延伸

          单个选择器可以扩展多个选择器。这意味着它会继承所有扩展选择器的样式。例如：

          ```
          .error {
            border: 1px #f00;
            background-color: #fdd;
          }
          .attention {
            font-size: 3em;
            background-color: #ff0;
          }
          .seriousError {
            @extend .error;
            @extend .attention;
            border-width: 3px;
          }

          ```
      - 链接扩展

          一个选择器可以扩展另一个选择器，而另一个选择器又扩展了第三个。例如：
          ```
          .error {
            border: 1px #f00;
            background-color: #fdd;
          }
          .seriousError {
            @extend .error;
            border-width: 3px;
          }
          .criticalError {
            @extend .seriousError;
            position: fixed;
            top: 10%;
            bottom: 10%;
            left: 10%;
            right: 10%;
          }

          ```
      - @extend-Only Selectors

          在编写Sass库时,我们可以通过占位符选择器编写一些样式,如果没有用到他们.就会忽略它们的存在,如果使用了就会进行渲染生效.

          ```
          // This ruleset won't be rendered on its own.
          #context a%extreme {
            color: blue;
            font-weight: bold;
            font-size: 2em;
          }
          .notice {
            @extend %extreme;
          }

          ```
      - @at-root

          @at-root指令导致一个或多个规则在文档的根目录下发布，而不是嵌套在其父选择器的下面。它可以与单个内联选择器一起使用：

          ```
          .parent {
            ...
            @at-root {
              .child1 { ... }
              .child2 { ... }
            }
            .step-child { ... }
          }
          ```
          编译后
          ```
          .parent { ... }
          .child1 { ... }
          .child2 { ... }
          .parent .step-child { ... }
          ```

      - @at-root (without: ...) 和 @at-root (with: ...)

          ```
          @media print {
            .page {
              width: 8in;
              @at-root (without: media) {
                color: red;
              }
            }
        }
          ```
          编译后

          ```
          @media print {
            .page {
              width: 8in;
            }
          }
          .page {
            color: red;
          }

          ```

  - 控制指令和表达式

    SassScript支持基本控制指令和表达式，仅在某些条件下包含样式，或者使用变体多次包含相同的样式。

    注意：控制指令是高级功能，在日常样式中不常见。它们主要存在用于混入.

    - if()

      内置if()函数允许您在条件下分支，并只返回两种可能的结果之一。它可以在任何脚本上下文中使用。该if函数仅评估与其将返回的参数相对应的参数 - 这允许您引用可能未定义的变量，或者计算否则会导致错误（例如除以零）。
      ```
        if(true, 1px, 2px) => 1px
      ```

    - @if

      @if指令采用SassScript表达式，如果表达式返回除false或null之外的任何值，则使用嵌套在其下的样式：
      ```
      p {
        @if 1 + 1 == 2 { border: 1px solid;  }
        @if 5 < 3      { border: 2px dotted; }
        @if null       { border: 3px double; }
      }
      ```
      @if语句后面可以有几个@else if语句和一个@else语句。如果@if语句失败，则@else if语句将按顺序尝试，直到成功或@​​else达到。

      ```
      $type: monster;
      p {
        @if $type == ocean {
          color: blue;
        } @else if $type == matador {
          color: red;
        } @else if $type == monster {
          color: green;
        } @else {
          color: black;
        }
      }
      ```
    - @for

      该@for指令重复输出一组样式。对于每次重复，计数变量被用来调整输出。该指令有两种形式：
      @for是$ var从<起点>到<终点>和
      @for是$ var从<开始>到<结束>。
      注意通过，并在关键字的区别。是$ var可以是任何变量名，如$ I; <启动>和<END>是应当返回整数SassScript表达式。

      该demo,@for语句将是$ var到指定范围内的每一个连续的号码，每次使用$ VAR的那个值输出嵌套样式。用于从通过...的形式，该范围包括的值<启动>和<END>，但形式从...到运行直到但不包括<END>的值。使用过的语法，
      ```
      @for $i from 1 through 3 {
        .item-#{$i} { width: 2em * $i; }
      }
      ```
    - @each

      该@each规则在<列表>的形式@each $变种。 $变种可以是任何变量的名字，如$长度或$名称，<列表>为一个SassScript表达式，返回的列表。
      ```
      @each $animal in puma, sea-slug, egret, salamander {
        .#{$animal}-icon {
          background-image: url('/images/#{$animal}.png');
        }
      }
      ```
    - @while

      该@while指令需要SassScript表达式反复执行，直到语句评估为假输出嵌套样式。这可以用来实现更复杂的循环。
      ```
      $i: 6;
      @while $i > 0 {
        .item-#{$i} { width: 2em * $i; }
        $i: $i - 2;
      }
      ```
  - Mixin 指令

    混入允许你定义整个风格样式表，可重复使用，而无需求助于非语义类，如.float左。混入还可以包含完整的CSS规则，他们也可以带参数。

    Mixins用@mixin指令定义。之后是mixin的名称，可选的参数，以及包含mixin内容的块。例如，large-textmixin定义如下：

    ```
    @mixin large-text {
      font: {
        family: Arial;
        size: 20px;
        weight: bold;
      }
      color: #ff0000;
    }

    ```

    MixinL里面还可以包含各种选择器.

    引用一个Mixin: @include mixin名称(可参数)

    ```
    .page-title {
      @include large-text;
      padding: 4px;
      margin-top: 10px;
    }
    ```

    Mixins也可以被包括在任何规则之外（也就是文档的根目录），只要它们不直接定义任何属性或使用任何父参照.

    ```
    @mixin silly-links {
      a {
        color: blue;
        background-color: red;
      }
    }

    @include silly-links
    ```

    也可以在定义一个Mixin时候,引用其他的Mixin.

    ```
    @mixin compound {
      @include highlighted-background;
      @include header-text;
    }
    ```
    Mixins还可以使用正常的变量设置语法为其参数指定默认值。然后，当包含mixin时，如果它不通过该参数，将使用默认值.

    ```
    @mixin sexy-border($color, $width: 1in) {
      border: {
        color: $color;
        width: $width;
        style: dashed;
      }
    }
    p { @include sexy-border(blue); }
    ```
    关键字参数:

    也可以使用显式关键字参数来包含Mixins。例如，

    ```
      p { @include sexy-border($color: blue); }
    ```
    可变参数:

    一个mixin采取未知数量的参数,通过...

    ```
    @mixin box-shadow($shadows...) {
      -moz-box-shadow: $shadows;
      -webkit-box-shadow: $shadows;
      box-shadow: $shadows;
    }

    .shadows {
      @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
    }

    ```

    调用一个mixin时也可以使用变量参数。使用相同的语法，您可以展开一个值列表，以便每个值作为单独的参数传递.

    ```
    @mixin colors($text, $background, $border) {
      color: $text;
      background-color: $background;
      border-color: $border;
    }

    $values: #ff0000, #00ff00, #0000ff;
    .primary {
        @include colors($values...);
    }

    ```

    将内容块传递给Mixin:

    可以通过@content将一组样式传递给mixin.

    ```
    @mixin apply-to-ie6-only {
      * html {
        @content;
      }
    }
    @include apply-to-ie6-only {
      #logo {
        background-image: url(/logo.gif);
      }
    }
    ```
    编译后

    ```
      * html #logo {
        background-image: url(/logo.gif);
    }
    ```

    
